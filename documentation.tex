\documentclass[12pt,a4paper]{report}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}

% Geometry
\geometry{margin=1in}

% Colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{darkblue}{rgb}{0,0,0.6}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=darkblue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Rates Risk Library Documentation},
    pdfauthor={},
    bookmarks=true
}

% Code listing style
\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=Python
}
\lstset{style=pythonstyle}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{Rates Risk Library v0.1.0}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Theorem environments
\newtheorem{definition}{Definition}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}{Remark}[chapter]

% Custom commands
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\df}{\text{DF}}
\newcommand{\zr}{\text{ZR}}
\newcommand{\pv}{\text{PV}}

% Title
\title{
    \vspace{-2cm}
    \rule{\linewidth}{0.5mm} \\[0.4cm]
    {\Huge \bfseries Rates Risk Library} \\[0.3cm]
    {\Large Technical Documentation} \\[0.2cm]
    \rule{\linewidth}{0.5mm} \\[1cm]
    {\large Version 0.1.0} \\[0.5cm]
    {\large A Comprehensive Python Library for\\
    Yield Curve Construction, Fixed-Income Pricing,\\
    and Risk Analytics}
}
\author{}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\tableofcontents
\newpage

%===============================================================================
% CHAPTER 1: INTRODUCTION
%===============================================================================
\chapter{Introduction}

\section{Overview}

The \textbf{Rates Risk Library} (\code{rateslib}) is a comprehensive Python library designed for USD yield curve construction, fixed-income instrument pricing, and risk analytics. It provides a complete toolkit for trading desk workflows including:

\begin{itemize}
    \item Real-time risk monitoring with DV01 and key-rate duration
    \item P\&L attribution and explain (linear and options)
    \item Value-at-Risk (VaR) calculations (historical, Monte Carlo, stressed)
    \item Scenario analysis and stress testing with curve and vol shocks
    \item SABR volatility surface calibration and smile-consistent pricing
    \item Options pricing (caplets, swaptions) with model-consistent Greeks
    \item Liquidity-adjusted VaR (LVaR) for stressed market conditions
    \item Interactive Streamlit dashboard with 8 comprehensive tabs
    \item Regulatory risk metrics and limit monitoring
\end{itemize}

\section{Library Architecture}

The library is organized into the following modules:

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{10cm}@{}}
\toprule
\textbf{Module} & \textbf{Description} \\
\midrule
\code{conventions} & Day count conventions, business day adjustments, compounding conventions \\
\code{dates} & Date utilities, tenor parsing, schedule generation \\
\code{curves} & Yield curve construction, bootstrapping, Nelson-Siegel-Svensson fitting \\
\code{pricers} & Bond, swap, and futures pricing engines with dispatcher \\
\code{risk} & DV01, key-rate duration, convexity, bump-and-reprice framework, limit monitoring \\
\code{var} & Historical simulation, Monte Carlo VaR, stressed VaR, scenario engine \\
\code{pnl} & P\&L attribution for linear and options (Greeks-based decomposition) \\
\code{vol} & SABR model, volatility surface with bucketing, calibration, wildcard support \\
\code{options} & Caplet/swaption pricing, SABR-consistent Greeks (delta, vega, vanna, volga) \\
\code{portfolio} & Production-grade trade builders with validation and failure diagnostics \\
\code{market\_state} & MarketState container for curves, SABR surface, and market data \\
\code{liquidity} & Liquidity risk metrics and liquidity-adjusted VaR (LVaR) \\
\code{reporting} & Risk reporting engine with coverage metrics and warnings \\
\bottomrule
\end{tabular}
\caption{Library Module Structure}
\end{table}

\section{Installation}

\begin{lstlisting}
# Clone the repository
git clone https://github.com/7josh7/rates_risk_lib.git
cd rates_risk_lib

# Install in development mode
pip install -e .

# Or install core dependencies directly
pip install numpy pandas scipy pyyaml

# Optional: dashboards
pip install -r dashboard/requirements_interactive.txt   # Streamlit dashboard
pip install -r dashboard/requirements.txt               # Shiny dashboard

# Run the interactive dashboard
cd dashboard
streamlit run interactive_dashboard.py
\end{lstlisting}

\subsection{Dashboard Quick Start}

The library includes a comprehensive Streamlit dashboard with 8 tabs:

\begin{enumerate}
    \item \textbf{Curves}: OIS/Treasury curves, SABR surface visualization
    \item \textbf{Pricing}: Bonds, swaps, futures, options with SABR
    \item \textbf{Risk Metrics}: Portfolio DV01, key-rate, convexity, SABR diagnostics
    \item \textbf{VaR Analysis}: Historical, Monte Carlo, stressed VaR
    \item \textbf{Scenarios}: Standard scenarios, vol-only shocks, SABR tail stress
    \item \textbf{P\&L Attribution}: Curve vs vol decomposition, options Greeks P\&L
    \item \textbf{Liquidity Risk}: LVaR with bid-ask spreads
    \item \textbf{Data Explorer}: Portfolio positions, vol quotes, market data
\end{enumerate}

%===============================================================================
% CHAPTER 2: CONVENTIONS
%===============================================================================
\chapter{Conventions and Date Utilities}

\section{Day Count Conventions}

Day count conventions determine how interest accrues between two dates. The library supports the following conventions:

\subsection{ACT/360}

Used for money markets and OIS swaps:
\begin{equation}
    \text{Year Fraction} = \frac{\text{Actual Days}}{360}
\end{equation}

\subsection{ACT/365}

Used for some fixed-income instruments:
\begin{equation}
    \text{Year Fraction} = \frac{\text{Actual Days}}{365}
\end{equation}

\subsection{ACT/ACT (ISDA)}

Used for US Treasury bonds. For periods spanning multiple years:
\begin{equation}
    \text{Year Fraction} = \sum_{y=y_1}^{y_2} \frac{\text{Days in year } y}{\text{Actual days in year } y}
\end{equation}

where days in year $y$ is 366 for leap years and 365 otherwise.

\subsection{30/360}

Used for some swap fixed legs:
\begin{equation}
    \text{Year Fraction} = \frac{360(Y_2-Y_1) + 30(M_2-M_1) + (D_2-D_1)}{360}
\end{equation}

\begin{lstlisting}
from rateslib import DayCount, year_fraction
from datetime import date

# Calculate year fraction using ACT/360
start = date(2024, 1, 15)
end = date(2024, 7, 15)
yf = year_fraction(start, end, DayCount.ACT_360)
print(f"ACT/360: {yf:.6f}")  # 181/360 = 0.502778
\end{lstlisting}

\section{Business Day Conventions}

\begin{definition}[Modified Following]
If a date falls on a weekend or holiday, move to the next business day unless it falls in the next month, in which case move to the previous business day.
\end{definition}

\begin{definition}[Following]
Move to the next business day if the date falls on a non-business day.
\end{definition}

\begin{definition}[Preceding]
Move to the previous business day if the date falls on a non-business day.
\end{definition}

\section{Compounding Conventions}

The library supports multiple compounding conventions for interest rate calculations:

\begin{table}[H]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Convention} & \textbf{Formula} \\
\midrule
Continuous & $\df(t) = e^{-r \cdot t}$ \\
Annual & $\df(t) = (1 + r)^{-t}$ \\
Semi-annual & $\df(t) = (1 + r/2)^{-2t}$ \\
Simple & $\df(t) = (1 + r \cdot t)^{-1}$ \\
\bottomrule
\end{tabular}
\caption{Compounding Conventions}
\end{table}

\section{Standard USD Conventions}

\begin{lstlisting}
from rateslib import Conventions

# USD OIS conventions
ois_conv = Conventions.usd_ois()
# Day count: ACT/360, Annual payment, 2-day settlement

# USD Treasury conventions  
tsy_conv = Conventions.usd_treasury()
# Day count: ACT/ACT, Semi-annual coupon, 1-day settlement

# USD Swap conventions
swap_conv = Conventions.usd_swap()
# Day count: ACT/360, Semi-annual fixed leg
\end{lstlisting}

\section{Date Utilities}

\subsection{Tenor Parsing}

The \code{DateUtils} class provides utilities for parsing and manipulating tenors:

\begin{lstlisting}
from rateslib.dates import DateUtils
from datetime import date

# Parse tenor
amount, unit = DateUtils.parse_tenor("3M")  # (3, 'M')

# Add tenor to date
start = date(2024, 1, 15)
end = DateUtils.add_tenor(start, "6M")  # 2024-07-15

# Convert tenor to years
years = DateUtils.tenor_to_years("2Y")  # 2.0
years = DateUtils.tenor_to_years("6M")  # 0.5
\end{lstlisting}

\subsection{Schedule Generation}

\begin{lstlisting}
from rateslib.dates import generate_bond_schedule, generate_swap_schedule

# Generate bond payment schedule
schedule = generate_bond_schedule(
    settlement=date(2024, 1, 15),
    maturity=date(2029, 1, 15),
    frequency=2,  # Semi-annual
    day_count=DayCount.ACT_ACT
)
\end{lstlisting}

%===============================================================================
% CHAPTER 3: YIELD CURVES
%===============================================================================
\chapter{Yield Curve Construction}

\section{Curve Representation}

\subsection{Mathematical Foundation}

A yield curve represents the term structure of interest rates. The library stores curves using discount factors $P(0,t)$ at discrete nodes and interpolates between them.

\begin{definition}[Discount Factor]
The discount factor $P(0,t)$ is the present value of \$1 received at time $t$:
\begin{equation}
    P(0,t) = e^{-z(t) \cdot t}
\end{equation}
where $z(t)$ is the continuously compounded zero rate.
\end{definition}

\begin{definition}[Zero Rate]
The continuously compounded zero rate $z(t)$ satisfies:
\begin{equation}
    z(t) = -\frac{\ln P(0,t)}{t}
\end{equation}
\end{definition}

\begin{definition}[Forward Rate]
The forward rate $f(t_1, t_2)$ for the period $[t_1, t_2]$ is:
\begin{equation}
    f(t_1, t_2) = \frac{1}{t_2 - t_1} \left( \frac{P(0,t_1)}{P(0,t_2)} - 1 \right)
\end{equation}
\end{definition}

\begin{definition}[Instantaneous Forward Rate]
The instantaneous forward rate is:
\begin{equation}
    f(t) = \lim_{\Delta t \to 0} f(t, t+\Delta t) = -\frac{\partial \ln P(0,t)}{\partial t}
\end{equation}
\end{definition}

\subsection{Curve Class API}

\begin{lstlisting}
from rateslib import Curve
from datetime import date

# Create a curve
curve = Curve(
    anchor_date=date(2024, 1, 15),
    currency="USD",
    day_count=DayCount.ACT_365,
    interpolation_method="cubic_spline"
)

# Add discount factor nodes
curve.add_node(time=0.5, discount_factor=0.9750)
curve.add_node(time=1.0, discount_factor=0.9500)
curve.add_node(time=2.0, discount_factor=0.9050)

# Build interpolator
curve.build()

# Query the curve
df = curve.discount_factor(1.5)      # Discount factor at 1.5 years
zr = curve.zero_rate(2.0)            # Zero rate at 2 years
fwd = curve.forward_rate(1.0, 2.0)   # Forward rate 1Y to 2Y
\end{lstlisting}

\section{OIS Curve Bootstrapping}

\subsection{Bootstrap Algorithm}

The OIS bootstrapper builds a discount curve sequentially from market quotes:

\begin{enumerate}
    \item Sort instruments by maturity
    \item For each instrument, solve for the discount factor that reprices the quote
    \item Verify that all instruments reprice within tolerance
\end{enumerate}

\subsection{Deposit Pricing}

For a deposit with rate $r$ and maturity $T$:
\begin{equation}
    P(0,T) = \frac{1}{1 + r \cdot \tau}
\end{equation}
where $\tau$ is the day count fraction.

\subsection{OIS Swap Pricing}

For an OIS swap with fixed rate $K$ and payment dates $\{T_i\}_{i=1}^n$:
\begin{equation}
    \sum_{i=1}^{n} K \cdot \delta_i \cdot P(0,T_i) = P(0,T_0) - P(0,T_n)
\end{equation}
where $\delta_i$ is the day count fraction for period $i$.

Solving for the unknown discount factor:
\begin{equation}
    P(0,T_n) = \frac{P(0,T_0) - K \sum_{i=1}^{n-1} \delta_i \cdot P(0,T_i)}{1 + K \cdot \delta_n}
\end{equation}

\subsection{API Usage}

\begin{lstlisting}
from rateslib import OISBootstrapper
from datetime import date

# Initialize bootstrapper
bootstrapper = OISBootstrapper(
    anchor_date=date(2024, 1, 15),
    day_count=DayCount.ACT_360,
    tolerance=1e-8
)

# Add market quotes
quotes = [
    ("1M", 0.0530),
    ("3M", 0.0528),
    ("6M", 0.0525),
    ("1Y", 0.0520),
    ("2Y", 0.0510),
    ("5Y", 0.0480),
    ("10Y", 0.0450),
    ("30Y", 0.0420),
]

# Bootstrap the curve
instruments = [create_ois_instrument(tenor, rate) 
               for tenor, rate in quotes]
result = bootstrapper.bootstrap(instruments, verify=True)

if result.success:
    curve = result.curve
    print("Bootstrap successful!")
    print(f"Max repricing error: {max(result.repricing_errors.values()):.2e}")
\end{lstlisting}

\section{Nelson-Siegel-Svensson Model}

\subsection{Model Specification}

The Nelson-Siegel-Svensson (NSS) model provides a parsimonious parametric representation of the yield curve using six parameters:

\begin{equation}
    y(\tau) = \beta_0 + \beta_1 \left( \frac{1-e^{-\tau/\lambda_1}}{\tau/\lambda_1} \right) + \beta_2 \left( \frac{1-e^{-\tau/\lambda_1}}{\tau/\lambda_1} - e^{-\tau/\lambda_1} \right) + \beta_3 \left( \frac{1-e^{-\tau/\lambda_2}}{\tau/\lambda_2} - e^{-\tau/\lambda_2} \right)
\end{equation}

\subsection{Parameter Interpretation}

\begin{table}[H]
\centering
\begin{tabular}{@{}clp{8cm}@{}}
\toprule
\textbf{Parameter} & \textbf{Name} & \textbf{Economic Interpretation} \\
\midrule
$\beta_0$ & Level & Long-term asymptotic yield \\
$\beta_1$ & Slope & Short-term component, controls slope \\
$\beta_2$ & Curvature 1 & Medium-term hump \\
$\beta_3$ & Curvature 2 & Second hump (Svensson extension) \\
$\lambda_1$ & Decay 1 & Controls location of first hump \\
$\lambda_2$ & Decay 2 & Controls location of second hump \\
\bottomrule
\end{tabular}
\caption{NSS Model Parameters}
\end{table}

\subsection{Limiting Behavior}

As $\tau \to 0$: $y(0) = \beta_0 + \beta_1$ (short rate)

As $\tau \to \infty$: $y(\infty) = \beta_0$ (long-term level)

\subsection{Instantaneous Forward Rate}

The instantaneous forward rate under NSS is:
\begin{equation}
    f(\tau) = \beta_0 + \beta_1 e^{-\tau/\lambda_1} + \beta_2 \frac{\tau}{\lambda_1} e^{-\tau/\lambda_1} + \beta_3 \frac{\tau}{\lambda_2} e^{-\tau/\lambda_2}
\end{equation}

\subsection{Fitting Algorithm}

The model is fitted by minimizing weighted squared errors:
\begin{equation}
    \min_{\theta} \sum_{i=1}^{n} w_i \left( y(\tau_i; \theta) - y_i^{\text{obs}} \right)^2
\end{equation}

The library uses L-BFGS-B with bounds, falling back to differential evolution for global optimization if local methods fail.

\subsection{API Usage}

\begin{lstlisting}
from rateslib import NelsonSiegelSvensson
from datetime import date

# Initialize NSS model
nss = NelsonSiegelSvensson(
    anchor_date=date(2024, 1, 15),
    day_count=DayCount.ACT_ACT
)

# Fit to Treasury par yields
tenors = ["3M", "6M", "1Y", "2Y", "3Y", "5Y", "7Y", "10Y", "20Y", "30Y"]
par_yields = [0.0525, 0.0520, 0.0512, 0.0485, 0.0470, 0.0455, 
              0.0450, 0.0445, 0.0460, 0.0448]

error, residuals = nss.fit_from_par_yields(tenors, par_yields)
print(f"Fit error: {error:.2e}")
print(f"Parameters: {nss.params}")

# Query the fitted model
yield_5y = nss.yield_at(5.0)
df_10y = nss.discount_factor(10.0)
fwd_rate = nss.forward_rate(5.0, 10.0)

# Convert to Curve object
curve = nss.to_curve()
\end{lstlisting}

%===============================================================================
% CHAPTER 4: INSTRUMENT PRICING
%===============================================================================
\chapter{Instrument Pricing}

\section{Bond Pricing}

\subsection{Coupon Bond Valuation}

The price of a coupon bond is the present value of its cashflows:
\begin{equation}
    P_{\text{dirty}} = \sum_{i=1}^{n} C \cdot P(0,t_i) + F \cdot P(0,T)
\end{equation}

where:
\begin{itemize}
    \item $C$ = coupon payment (face value $\times$ coupon rate / frequency)
    \item $F$ = face value (typically 100)
    \item $t_i$ = coupon payment dates
    \item $T$ = maturity date
\end{itemize}

\subsection{Clean vs Dirty Price}

\begin{equation}
    P_{\text{clean}} = P_{\text{dirty}} - \text{Accrued Interest}
\end{equation}

\begin{equation}
    \text{Accrued Interest} = C \times \frac{\text{Days since last coupon}}{\text{Days in coupon period}}
\end{equation}

\subsection{Yield to Maturity}

The yield to maturity $y$ is the internal rate of return that equates price to cashflows:
\begin{equation}
    P = \sum_{i=1}^{n} \frac{C}{(1+y/m)^{m \cdot t_i}} + \frac{F}{(1+y/m)^{m \cdot T}}
\end{equation}

where $m$ is the coupon frequency per year.

\subsection{BondPricer API}

\begin{lstlisting}
from rateslib import BondPricer, Conventions

# Create pricer with curve
pricer = BondPricer(
    curve=discount_curve,
    conventions=Conventions.usd_treasury()
)

# Price a bond
dirty, clean, accrued = pricer.price(
    settlement=date(2024, 1, 15),
    maturity=date(2029, 1, 15),
    coupon_rate=0.04,  # 4% annual coupon
    face_value=100.0,
    frequency=2  # Semi-annual
)

print(f"Dirty Price: {dirty:.4f}")
print(f"Clean Price: {clean:.4f}")
print(f"Accrued Interest: {accrued:.4f}")

# Compute DV01
dv01 = pricer.compute_dv01(
    settlement=date(2024, 1, 15),
    maturity=date(2029, 1, 15),
    coupon_rate=0.04,
    face_value=100.0
)
\end{lstlisting}

\section{Interest Rate Swap Pricing}

\subsection{Vanilla IRS Valuation}

A vanilla interest rate swap exchanges fixed for floating payments. The present value is:
\begin{equation}
    \pv_{\text{swap}} = \pv_{\text{float}} - \pv_{\text{fixed}}
\end{equation}

\subsubsection{Fixed Leg}

\begin{equation}
    \pv_{\text{fixed}} = K \sum_{i=1}^{n} \delta_i \cdot P(0,T_i)
\end{equation}

where $K$ is the fixed rate and $\delta_i$ is the day count fraction.

\subsubsection{Floating Leg}

At inception (par swap):
\begin{equation}
    \pv_{\text{float}} = P(0,T_0) - P(0,T_n)
\end{equation}

For an off-market swap:
\begin{equation}
    \pv_{\text{float}} = \sum_{j=1}^{m} F_j \cdot \delta_j \cdot P(0,T_j)
\end{equation}

where $F_j$ is the forward rate for period $j$:
\begin{equation}
    F_j = \frac{1}{\delta_j} \left( \frac{P(0,T_{j-1})}{P(0,T_j)} - 1 \right)
\end{equation}

\subsection{Par Swap Rate}

The par swap rate is the fixed rate that makes the swap have zero value:
\begin{equation}
    K_{\text{par}} = \frac{P(0,T_0) - P(0,T_n)}{\sum_{i=1}^{n} \delta_i \cdot P(0,T_i)}
\end{equation}

\subsection{SwapPricer API}

\begin{lstlisting}
from rateslib import SwapPricer

# Create pricer with discount and projection curves
pricer = SwapPricer(
    discount_curve=ois_curve,
    projection_curve=libor_curve  # Optional, defaults to discount
)

# Price a swap
pv = pricer.present_value(
    effective=date(2024, 1, 17),
    maturity=date(2029, 1, 17),
    notional=10_000_000,
    fixed_rate=0.045,
    pay_receive="PAY"  # Pay fixed, receive float
)

# Calculate par rate
par_rate = pricer.par_rate(
    effective=date(2024, 1, 17),
    maturity=date(2029, 1, 17)
)
print(f"5Y Par Swap Rate: {par_rate*100:.4f}%")
\end{lstlisting}

\section{Futures Pricing}

\subsection{SOFR Futures}

SOFR futures settle to the average SOFR rate over the contract period:
\begin{equation}
    \text{Price} = 100 - \text{Implied Rate} \times 100
\end{equation}

\begin{equation}
    \text{Implied Rate} = \frac{1}{\tau} \left( \frac{P(0,T_1)}{P(0,T_2)} - 1 \right)
\end{equation}

\subsection{Convexity Adjustment}

Futures rates require a convexity adjustment relative to forward rates due to daily margining:
\begin{equation}
    \text{Forward Rate} \approx \text{Futures Rate} - \text{Convexity Adjustment}
\end{equation}

A simple approximation:
\begin{equation}
    \text{Convexity Adj} = \frac{1}{2} \sigma^2 T_1 T_2
\end{equation}

\subsection{FuturesPricer API}

\begin{lstlisting}
from rateslib import FuturesPricer

pricer = FuturesPricer(curve=ois_curve)

# Price a 3-month SOFR future
price = pricer.price(
    contract_start=date(2024, 3, 20),
    contract_end=date(2024, 6, 19),
    tick_value=25.0
)

# Get implied rate
implied_rate = pricer.implied_rate(
    contract_start=date(2024, 3, 20),
    contract_end=date(2024, 6, 19)
)
\end{lstlisting}

%===============================================================================
% CHAPTER 5: RISK METRICS
%===============================================================================
\chapter{Risk Metrics}

\section{DV01 (Dollar Value of 01)}

\subsection{Definition}

DV01 measures the change in portfolio value for a 1 basis point parallel shift in the yield curve:
\begin{equation}
    \text{DV01} = \frac{\pv(\text{curve} - 1\text{bp}) - \pv(\text{curve} + 1\text{bp})}{2}
\end{equation}

\subsection{Relationship to Modified Duration}

For a bond:
\begin{equation}
    \text{DV01} = \frac{\text{Modified Duration} \times \text{Price}}{10{,}000}
\end{equation}

\begin{equation}
    \text{Modified Duration} = -\frac{\text{DV01} \times 10{,}000}{\pv}
\end{equation}

\section{Convexity}

\subsection{Definition}

Convexity measures the curvature of the price-yield relationship:
\begin{equation}
    \text{Convexity} = \frac{\pv(+\Delta y) + \pv(-\Delta y) - 2 \cdot \pv(0)}{(\Delta y)^2 \cdot \pv(0)}
\end{equation}

\subsection{Taylor Expansion}

Price change for a yield change $\Delta y$:
\begin{equation}
    \Delta \pv \approx -\text{Duration} \times \pv \times \Delta y + \frac{1}{2} \times \text{Convexity} \times \pv \times (\Delta y)^2
\end{equation}

\section{Key-Rate Duration}

\subsection{Motivation}

Key-rate durations (KRDs) capture sensitivity to non-parallel curve movements by bumping individual tenors:
\begin{equation}
    \text{KRD}_i = \frac{\pv(\text{curve with tenor } i \text{ bumped}) - \pv(\text{base})}{\Delta r_i}
\end{equation}

\subsection{Standard Tenors}

The library uses these standard key-rate tenors:
\begin{center}
3M, 6M, 1Y, 2Y, 3Y, 5Y, 7Y, 10Y, 15Y, 20Y, 30Y
\end{center}

\subsection{Hedging Applications}

Key-rate DV01s are essential for:
\begin{itemize}
    \item Curve-neutral hedging
    \item Immunizing against twist/butterfly moves
    \item Regulatory risk reporting
\end{itemize}

\section{BumpEngine API}

\begin{lstlisting}
from rateslib.risk import BumpEngine

# Create bump engine
engine = BumpEngine(base_curve=ois_curve)

# Parallel bump
bumped_curve = engine.parallel_bump(bp=10)  # +10bp parallel

# Single tenor bump
bumped_curve = engine.tenor_bump(tenor="5Y", bp=5)  # +5bp at 5Y

# Compute DV01
def portfolio_pv(curve):
    return sum(pricer.price(curve) for pricer in portfolio)

dv01 = engine.compute_dv01(pricer_func=portfolio_pv, bump_size=1.0)
convexity = engine.compute_convexity(pricer_func=portfolio_pv, bump_size=1.0)
\end{lstlisting}

\section{KeyRateEngine API}

\begin{lstlisting}
from rateslib.risk import KeyRateEngine, STANDARD_KEY_RATE_TENORS

# Create key-rate engine
kr_engine = KeyRateEngine(
    curve=ois_curve,
    tenors=STANDARD_KEY_RATE_TENORS,
    bump_size=1.0
)

# Compute key-rate DV01
kr_dv01 = kr_engine.compute_key_rate_dv01(pricer_func=portfolio_pv)

print(f"Total DV01: {kr_dv01.total_dv01:,.2f}")
for tenor, dv01 in kr_dv01.dv01s.items():
    print(f"  {tenor}: {dv01:,.2f}")
\end{lstlisting}

\section{RiskCalculator API}

\begin{lstlisting}
from rateslib.risk import RiskCalculator

# Create calculator
calc = RiskCalculator(curve=ois_curve, bump_size=1.0)

# Compute bond risk
bond_risk = calc.compute_bond_risk(
    instrument_id="UST_5Y",
    settlement=date(2024, 1, 15),
    maturity=date(2029, 1, 15),
    coupon_rate=0.04,
    notional=10_000_000,
    frequency=2
)

print(f"PV: ${bond_risk.pv:,.2f}")
print(f"DV01: ${bond_risk.dv01:,.2f}")
print(f"Modified Duration: {bond_risk.modified_duration:.2f} years")
print(f"Convexity: {bond_risk.convexity:,.4f}")
\end{lstlisting}

%===============================================================================
% CHAPTER 6: VALUE AT RISK
%===============================================================================
\chapter{Value at Risk and Expected Shortfall}

\section{Historical Simulation VaR}

\subsection{Methodology}

Historical simulation uses observed rate changes to estimate the P\&L distribution:

\begin{enumerate}
    \item Extract historical rate changes $\{\Delta r_t\}$ from a lookback window
    \item For each historical scenario, apply rate changes to today's curve
    \item Reprice the portfolio under each shocked curve
    \item Compute P\&L distribution
    \item VaR is the loss at the specified percentile
\end{enumerate}

\subsection{VaR Calculation}

\begin{equation}
    \text{VaR}_\alpha = -\text{Quantile}_{1-\alpha}(\text{P\&L distribution})
\end{equation}

For 95\% VaR: loss exceeded in only 5\% of scenarios.

\subsection{Expected Shortfall}

Expected Shortfall (ES), also called CVaR, is the expected loss given that VaR is breached:
\begin{equation}
    \text{ES}_\alpha = -\mathbb{E}[\text{P\&L} \mid \text{P\&L} < -\text{VaR}_\alpha]
\end{equation}

\subsection{API Usage}

\begin{lstlisting}
from rateslib.var import HistoricalSimulation
import pandas as pd

# Load historical rate data
historical_data = pd.read_csv("rates_history.csv")

# Initialize historical simulation
hist_var = HistoricalSimulation(
    base_curve=ois_curve,
    historical_data=historical_data,
    pricer_func=portfolio_pv,
    tenors=["3M", "1Y", "2Y", "5Y", "10Y", "30Y"]
)

# Run simulation
result = hist_var.run_simulation(lookback_days=252)

print(f"95% VaR: ${result.var_95:,.2f}")
print(f"99% VaR: ${result.var_99:,.2f}")
print(f"95% ES:  ${result.es_95:,.2f}")
print(f"99% ES:  ${result.es_99:,.2f}")
\end{lstlisting}

\section{Monte Carlo VaR}

\subsection{Methodology}

Monte Carlo VaR simulates rate changes from a multivariate normal distribution:

\begin{enumerate}
    \item Estimate covariance matrix $\Sigma$ from historical data
    \item Generate correlated random rate changes: $\Delta r \sim \mathcal{N}(0, \Sigma)$
    \item Apply simulated shocks to the curve
    \item Reprice portfolio
    \item Compute VaR/ES from simulated P\&L distribution
\end{enumerate}

\subsection{Covariance Estimation}

\begin{equation}
    \hat{\Sigma}_{ij} = \frac{1}{T-1} \sum_{t=1}^{T} (\Delta r_{i,t} - \bar{\Delta r}_i)(\Delta r_{j,t} - \bar{\Delta r}_j)
\end{equation}

\subsection{Cholesky Decomposition}

To generate correlated samples, use Cholesky decomposition $\Sigma = LL^T$:
\begin{equation}
    \Delta r = L \cdot z, \quad z \sim \mathcal{N}(0, I)
\end{equation}

\subsection{API Usage}

\begin{lstlisting}
from rateslib.var import MonteCarloVaR

# Initialize Monte Carlo engine
mc_var = MonteCarloVaR(
    base_curve=ois_curve,
    historical_data=historical_data,
    pricer_func=portfolio_pv,
    tenors=["3M", "1Y", "2Y", "5Y", "10Y", "30Y"]
)

# Run simulation
result = mc_var.run_simulation(num_paths=10000, seed=42)

print(f"95% VaR: ${result.var_95:,.2f}")
print(f"99% VaR: ${result.var_99:,.2f}")
print(f"Mean P&L: ${result.mean_pnl:,.2f}")
print(f"Std P&L: ${result.std_pnl:,.2f}")
\end{lstlisting}

\section{Scenario Analysis}

\subsection{Predefined Scenarios}

The library includes standard stress scenarios:

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Scenario} & \textbf{Description} \\
\midrule
\code{parallel\_up\_100} & +100bp parallel shift \\
\code{parallel\_down\_100} & -100bp parallel shift \\
\code{steepener\_2s10s} & 2Y -25bp, 10Y +25bp \\
\code{flattener\_2s10s} & 2Y +25bp, 10Y -25bp \\
\code{twist\_5y} & Short -50bp, Long +50bp, pivot at 5Y \\
\code{bear\_flattener} & Rates up, short end more (Fed hiking) \\
\code{bull\_steepener} & Rates down, short end more (Fed cutting) \\
\bottomrule
\end{tabular}
\caption{Standard Stress Scenarios}
\end{table}

\subsection{API Usage}

\begin{lstlisting}
from rateslib.var import ScenarioEngine, STANDARD_SCENARIOS

# Create scenario engine
engine = ScenarioEngine(
    base_curve=ois_curve,
    pricer_func=portfolio_pv,
    key_rate_dv01=kr_dv01.dv01s
)

# Run all standard scenarios
for name, scenario in STANDARD_SCENARIOS.items():
    result = engine.run_scenario(scenario)
    print(f"{scenario.name}: P&L = ${result.pnl:,.2f}")

# Custom scenario
from rateslib.var import Scenario

custom = Scenario(
    name="Fed Pivot",
    description="Front-end rallies 50bp, long-end sells off 25bp",
    bump_profile={
        "3M": -50, "6M": -50, "1Y": -40, "2Y": -30,
        "5Y": -10, "10Y": 10, "30Y": 25
    }
)
result = engine.run_scenario(custom)
\end{lstlisting}

%===============================================================================
% CHAPTER 7: P&L ATTRIBUTION
%===============================================================================
\chapter{P\&L Attribution}

\section{Attribution Framework}

\subsection{Components}

Daily P\&L is decomposed into:

\begin{equation}
    \text{Realized P\&L} = \text{Carry} + \text{Roll-down} + \text{Curve Move} + \text{Convexity} + \text{Residual}
\end{equation}

\subsection{Carry}

Carry is the income from holding the position, assuming no curve change:
\begin{equation}
    \text{Carry} = \text{Coupon Accrual} - \text{Funding Cost}
\end{equation}

For a bond:
\begin{equation}
    \text{Daily Carry} = \frac{\text{Annual Coupon}}{365}
\end{equation}

\subsection{Roll-down}

Roll-down captures the value change from the position aging one day on an unchanged curve:
\begin{equation}
    \text{Roll-down} = \pv(t+1, \text{curve}_t) - \pv(t, \text{curve}_t)
\end{equation}

\subsection{Curve Move}

Curve move P\&L is predicted from key-rate DV01s:
\begin{equation}
    \text{Curve Move} \approx \sum_{i} \text{KRD}_i \times \Delta r_i
\end{equation}

Split into parallel and non-parallel components:
\begin{equation}
    \text{Parallel} = \text{DV01} \times \overline{\Delta r}
\end{equation}
\begin{equation}
    \text{Non-parallel} = \sum_{i} \text{KRD}_i \times (\Delta r_i - \overline{\Delta r})
\end{equation}

\subsection{Convexity Effect}

Second-order correction for large curve moves:
\begin{equation}
    \text{Convexity P\&L} = \frac{1}{2} \times \text{Convexity} \times (\overline{\Delta r})^2
\end{equation}

\subsection{Residual}

Unexplained P\&L:
\begin{equation}
    \text{Residual} = \text{Realized} - \text{Predicted}
\end{equation}

Sources of residual:
\begin{itemize}
    \item Cross-gamma effects
    \item Interpolation differences
    \item Timing/settlement effects
    \item Model limitations
\end{itemize}

\section{API Usage}

\begin{lstlisting}
from rateslib.pnl import PnLAttributionEngine

# Initialize attribution engine
engine = PnLAttributionEngine(
    curve_t0=yesterday_curve,
    curve_t1=today_curve,
    date_t0=date(2024, 1, 14),
    date_t1=date(2024, 1, 15)
)

# Compute attribution for a bond
attribution = engine.attribute_pnl(
    instrument_id="UST_5Y",
    pricer_func_t0=lambda c, d: bond_pricer.price(c, d, ...),
    pricer_func_t1=lambda c, d: bond_pricer.price(c, d, ...),
    risk_t0=bond_risk
)

print(f"Realized P&L: ${attribution.realized_pnl:,.2f}")
print(f"  Carry: ${attribution.components.carry:,.2f}")
print(f"  Roll-down: ${attribution.components.rolldown:,.2f}")
print(f"  Curve Move: ${attribution.components.curve_move_total:,.2f}")
print(f"  Convexity: ${attribution.components.convexity:,.2f}")
print(f"  Residual: ${attribution.components.residual:,.2f}")
\end{lstlisting}

%===============================================================================
% CHAPTER 8: MARKET STATE ARCHITECTURE
%===============================================================================
\chapter{Market State Architecture}

\section{Overview}

The library uses a unified \code{MarketState} container to encapsulate all market data required for pricing and risk:

\begin{lstlisting}
from rateslib import MarketState, CurveState

# Create market state
market_state = MarketState(
    curve=CurveState(discount_curve=ois_curve,
                     projection_curve=libor_curve),
    sabr_surface=sabr_surface,  # Optional
    asof=date(2024, 1, 15)
)
\end{lstlisting}

\subsection{CurveState}

The \code{CurveState} wraps discount and projection curves:

\begin{lstlisting}
@dataclass
class CurveState:
    discount_curve: Curve
    projection_curve: Optional[Curve] = None
    
    def get_projection_curve(self) -> Curve:
        """Get projection curve, defaulting to discount."""
        return self.projection_curve or self.discount_curve
\end{lstlisting}

\subsection{SABR Surface State}

The \code{SabrSurfaceState} manages calibrated SABR parameters by bucket:

\begin{lstlisting}
from rateslib import SabrSurfaceState, SabrBucketParams

# Create SABR surface with bucketing
sabr_surface = SabrSurfaceState(
    params_by_bucket={
        ("1Y", "5Y"): SabrBucketParams(
            sigma_atm=0.0075, beta=0.5, rho=-0.20, nu=0.45
        ),
        ("2Y", "10Y"): SabrBucketParams(
            sigma_atm=0.0065, beta=0.5, rho=-0.15, nu=0.40
        ),
        # Wildcard bucket for missing expiry/tenor combinations
        ("ALL", "ALL"): SabrBucketParams(
            sigma_atm=0.0070, beta=0.5, rho=-0.18, nu=0.42
        )
    },
    missing_bucket_policy="nearest"  # Or "wildcard"
)

# Query parameters
params = sabr_surface.get_bucket_params("1Y", "5Y")
# Falls back to nearest or wildcard if not found
params_fallback = sabr_surface.get_bucket_params("18M", "7Y")
\end{lstlisting}

\subsection{Wildcard Bucket Support}

The library supports an \code{("ALL", "ALL")} wildcard bucket that acts as a universal fallback:

\begin{itemize}
    \item Checked after exact match fails
    \item Before nearest-neighbor search (if enabled)
    \item Skipped during distance calculations to avoid tenor parsing errors
    \item Useful for sparse calibration data or testing
\end{itemize}

\section{Portfolio Builders}

\subsection{Production-Grade Trade Construction}

The \code{portfolio} module provides validated trade builders:

\begin{lstlisting}
from rateslib.portfolio import (
    build_bond_trade,
    build_swap_trade,
    build_swaption_trade,
    build_caplet_trade,
    build_trade_from_position,
)

# Build from position row
try:
    trade = build_trade_from_position(
        position_row,
        market_state,
        valuation_date
    )
    pv = price_trade(trade, market_state).pv
except PositionValidationError as e:
    print(f"Validation failed: {e}")
except MissingFieldError as e:
    print(f"Missing required field: {e}")
except InvalidOptionError as e:
    print(f"Invalid option: {e}")
\end{lstlisting}

\subsection{Pricing with Diagnostics}

\begin{lstlisting}
from rateslib.portfolio import price_portfolio_with_diagnostics

result = price_portfolio_with_diagnostics(
    positions_df,
    market_state,
    valuation_date
)

print(f"Total PV: ${result.total_pv:,.2f}")
print(f"Positions priced: {result.successful_count}")
print(f"Positions failed: {result.failed_count}")

for failure in result.failures:
    print(f"  {failure.position_id}: {failure.error_message}")
\end{lstlisting}

%===============================================================================
% CHAPTER 9: RATES VOLATILITY AND SABR MODEL
%===============================================================================
\chapter{Rates Volatility and SABR Model Integration}

\section{Overview}

This chapter specifies the integration of the SABR stochastic volatility model into \code{rateslib} for pricing vanilla rates options (caplets and swaptions) with smile-consistent risk management.

\subsection{Integration Completeness Criteria}

The SABR integration is \textbf{fully complete} as of v0.1.0:
\begin{enumerate}[leftmargin=1.2em,itemsep=0.2em]
    \item \checkmark The architecture includes \code{vol}, \code{options}, \code{portfolio}, and \code{market\_state} modules.
    \item \checkmark The library ingests market vol quotes (normal or lognormal, with shift support), calibrates SABR parameters per bucket, and produces implied vols per strike.
    \item \checkmark Vanilla rates options (caplets and swaptions) are priced by:
    \[
    V = \text{BaseModelPrice}(F_0,K,T,\sigma_{\text{imp}}(K))
    \]
    \item \checkmark Risk reports include \textbf{model-consistent Greeks}: delta with smile-dynamics correction ($\Delta_{\text{SABR}}$), and vega/vanna/volga.
    \item \checkmark Production-grade portfolio builders with validation and failure diagnostics.
    \item \checkmark Wildcard bucket support (\code{("ALL", "ALL")}) for sparse calibration.
    \item \checkmark Options P\&L attribution with Greeks-based decomposition.
    \item \checkmark Comprehensive dashboard with SABR visualization across 8 tabs.
\end{enumerate}

\section{Volatility Quote Schema}

\subsection{Input Format}

Volatility quotes are provided in CSV format (\code{vol\_quotes.csv}):

\begin{verbatim}
date, expiry, underlying_tenor, strike, vol, vol_type, shift
2025-12-08, 1Y, 5Y, ATM, 0.0075, NORMAL, 0.00
2025-12-08, 1Y, 5Y, +25bp, 0.0078, NORMAL, 0.00
2025-12-08, 1Y, 5Y, -25bp, 0.0073, NORMAL, 0.00
2025-12-08, 1Y, 5Y, +50bp, 0.0082, NORMAL, 0.00
...
\end{verbatim}

\subsection{Schema Rules}

\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item \code{vol\_type} $\in\{\text{NORMAL},\text{LOGNORMAL}\}$
    \item If \code{shift} $> 0$, interpret the pricing convention as \emph{shifted lognormal}
    \item Support ATM conversion between normal and shifted lognormal by matching Bachelier and shifted-Black ATM prices
    \item Strike conventions: ATM, $\pm$25bp, $\pm$50bp, $\pm$100bp relative to forward
\end{itemize}

\section{SABR Model Specification}

\subsection{SABR Dynamics}

The SABR model specifies joint dynamics for the forward $F(t)$ and stochastic volatility factor $Z(t)$:

\begin{align}
    dF(t) &= \alpha Z(t) F(t)^\beta \, dW_1(t) \\
    dZ(t) &= \nu Z(t) \, dW_2(t) \\
    dW_1 \, dW_2 &= \rho \, dt
\end{align}

where:
\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item $\alpha > 0$: instantaneous volatility level
    \item $\beta \in [0,1]$: CEV exponent (backbone parameter)
    \item $\rho \in (-1,1)$: correlation between forward and vol
    \item $\nu \geq 0$: volatility of volatility
    \item $Z(0) = 1$ (normalized)
\end{itemize}

\subsection{Shifted SABR for Negative Rates}

For environments with negative rates, use the shifted SABR formulation:
\begin{equation}
    dF(t) = \alpha Z(t) \, (F(t) + \lambda)^\beta \, dW_1(t)
\end{equation}

where $\lambda$ is the shift parameter from \code{vol\_quotes.csv}. The shifted forward $\tilde{F} = F + \lambda$ is always positive.

\subsection{Hagan Implied Volatility Approximation}

The implied Black volatility $\sigma_B(K)$ is computed using the Hagan et al.\ approximation:

\begin{equation}
    \sigma_B(K,F,T) = \frac{\alpha}{(FK)^{(1-\beta)/2} \left[1 + \frac{(1-\beta)^2}{24}\ln^2\frac{F}{K} + \frac{(1-\beta)^4}{1920}\ln^4\frac{F}{K}\right]} \cdot \frac{z}{x(z)} \cdot \left[1 + \epsilon T\right]
\end{equation}

where:
\begin{align}
    z &= \frac{\nu}{\alpha}(FK)^{(1-\beta)/2}\ln\frac{F}{K} \\
    x(z) &= \ln\left[\frac{\sqrt{1-2\rho z + z^2} + z - \rho}{1-\rho}\right] \\
    \epsilon &= \frac{(1-\beta)^2\alpha^2}{24(FK)^{1-\beta}} + \frac{\rho\beta\nu\alpha}{4(FK)^{(1-\beta)/2}} + \frac{(2-3\rho^2)\nu^2}{24}
\end{align}

At ATM ($K=F$), this simplifies to:
\begin{equation}
    \sigma_B^{\text{ATM}} = \frac{\alpha}{F^{1-\beta}}\left[1 + \left(\frac{(1-\beta)^2\alpha^2}{24 F^{2-2\beta}} + \frac{\rho\beta\nu\alpha}{4 F^{1-\beta}} + \frac{(2-3\rho^2)\nu^2}{24}\right)T\right]
\end{equation}

\section{Complete SABR Workflow}

\subsection{End-to-End Example}

\begin{lstlisting}
from rateslib import (
    OISBootstrapper,
    build_sabr_surface,
    normalize_vol_quotes,
    MarketState,
    CurveState,
    build_trade_from_position,
    price_trade,
    SabrOptionRisk,
)
from datetime import date
import pandas as pd

valuation_date = date(2024, 1, 15)

# 1. Build an OIS curve from sample quotes
ois_quotes = pd.read_csv("data/sample_quotes/ois_quotes.csv", comment="#")
bootstrapper = OISBootstrapper(valuation_date)
for _, row in ois_quotes.iterrows():
    bootstrapper.add_quote(str(row["tenor"]), float(row["rate"]))
ois_curve = bootstrapper.bootstrap().curve

curve_state = CurveState(
    discount_curve=ois_curve,
    projection_curve=ois_curve,
    metadata={"valuation_date": str(valuation_date)},
)

# 2. Load and normalize vol quotes (requires curve_state)
vol_quotes_df = pd.read_csv("data/vol_quotes.csv", comment="#")
normalized = normalize_vol_quotes(vol_quotes_df, curve_state, instrument_hint="SWAPTION")

# 3. Build SABR surface (bucketed by expiry x tenor)
sabr_surface = build_sabr_surface(normalized, curve_state, beta_policy=0.5)

# 4. Create market state
market_state = MarketState(curve=curve_state, sabr_surface=sabr_surface, asof=str(valuation_date))

# 5. Build and price a swaption from the sample book
positions_df = pd.read_csv("data/sample_book/positions.csv", comment="#")
swaption_pos = positions_df[positions_df["instrument_type"] == "SWAPTION"].iloc[0]
swaption_trade = build_trade_from_position(swaption_pos, valuation_date)

price_result = price_trade(swaption_trade, market_state)
print(f"PV: ${price_result.pv:,.2f}")
print(f"Forward: {price_result.forward*100:.3f}%")
print(f"Implied Vol: {price_result.implied_vol*10000:.1f} bp")

# 6. Compute SABR-consistent risk
risk_engine = SabrOptionRisk(vol_type="NORMAL")

# Get SABR params for this bucket
params = market_state.sabr_surface.get_bucket_params("1Y", "5Y")
sabr_params = params.to_sabr_params()

# Compute risk report
risk_report = risk_engine.risk_report(
    F=price_result.forward,
    K=price_result.forward,  # ATM
    T=1.0,  # 1 year to expiry
    sabr_params=sabr_params,
    annuity=price_result.annuity,
    is_call=True,
    notional=float(swaption_trade.get("notional", 1.0))
)

print(f"\nRisk Report:")
print(f"  Delta (base):      {risk_report.delta_base:,.0f}")
print(f"  Delta (SABR):      {risk_report.delta_sabr:,.0f}")
print(f"  Delta (sideways):  {risk_report.delta_sideways:,.0f}")
print(f"  Delta (backbone):  {risk_report.delta_backbone:,.0f}")
print(f"  Vega (ATM):        {risk_report.vega_atm:,.0f}")
print(f"  Vanna:             {risk_report.vanna:,.0f}")
print(f"  Volga:             {risk_report.volga:,.0f}")
\end{lstlisting}

\subsection{Options P\&L Attribution Example}

\begin{lstlisting}
from rateslib.pnl.attribution import (
    compute_option_pnl_attribution,
    aggregate_options_attribution
)

# Load portfolio with options
positions_df = pd.read_csv('data/sample_book/positions.csv', 
                           comment='#')

# Compute attribution for 10bp rate move, 20bp vol move, 1 day
attributions = compute_option_pnl_attribution(
    positions_df=positions_df,
    market_state=market_state,
    valuation_date=valuation_date,
    rate_move_bp=10,
    vol_move_bp=20,
    days_passed=1
)

print(f"Found {len(attributions)} option positions\n")

for attr in attributions:
    print(f"{attr.instrument_id}:")
    print(f"  Delta P&L:  ${attr.delta_pnl:,.2f}")
    print(f"  Vega P&L:   ${attr.vega_pnl:,.2f}")
    print(f"  Gamma P&L:  ${attr.gamma_pnl:,.2f}")
    print(f"  Theta P&L:  ${attr.theta_pnl:,.2f}")
    print(f"  Total:      ${attr.total_pnl:,.2f}\n")

# Aggregate across portfolio
agg = aggregate_options_attribution(attributions)
print("Portfolio Totals:")
print(f"  Delta P&L:  ${agg['delta_pnl']:,.2f}")
print(f"  Vega P&L:   ${agg['vega_pnl']:,.2f}")
print(f"  Total P&L:  ${agg['total_pnl']:,.2f}")
print(f"  Total Delta: {agg['total_delta']:,.0f}")
print(f"  Total Vega:  {agg['total_vega']:,.0f}")
\end{lstlisting}

\section{Calibration}

\subsection{Alternative Parameterization}

For production use, calibrate in $(\sigma_{\text{ATM}}, \beta, \rho, \nu)$ rather than $(\alpha, \beta, \rho, \nu)$:

\begin{enumerate}[leftmargin=1.2em,itemsep=0.1em]
    \item Fix $\beta$ (typically from historical analysis or market convention)
    \item Given market $\sigma_{\text{ATM}}$, invert the ATM formula to obtain $\alpha$
    \item Calibrate $(\rho, \nu)$ to match the smile (OTM strikes)
\end{enumerate}

\textbf{Advantages:}
\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item ATM vol is directly observable and stable
    \item Avoids refitting $\alpha$ when ATM moves
    \item Vega is naturally defined w.r.t.\ $\sigma_{\text{ATM}}$
\end{itemize}

\subsection{Alpha Inversion}

Given the ATM formula $G(\alpha; \sigma_{\text{ATM}}, \beta, \rho, \nu, F, T) = 0$, solve for $\alpha$ numerically (Newton-Raphson or Brent).

\subsection{Implicit Differentiation for Risk}

Define $G(\alpha(\sigma_{\text{ATM}}, \theta), \theta) - \sigma_{\text{ATM}} = 0$ where $\theta = (\beta, \rho, \nu, F)$.

By implicit differentiation:
\begin{align}
    \frac{\partial \alpha}{\partial \sigma_{\text{ATM}}} &= \frac{1}{\partial G / \partial \alpha} \\
    \frac{\partial \alpha}{\partial \theta_i} &= -\frac{\partial G / \partial \theta_i}{\partial G / \partial \alpha}
\end{align}

These derivatives are required for computing vega w.r.t.\ $\sigma_{\text{ATM}}$.

\section{Base Pricing Models}

\subsection{Bachelier Model (Normal Vol)}

For normal volatility quoting:
\begin{equation}
    V_{\text{call}} = \text{DF} \cdot \left[(F-K)\Phi(d) + \sigma_N\sqrt{T}\phi(d)\right]
\end{equation}
where $d = (F-K)/(\sigma_N\sqrt{T})$, $\Phi$ is the standard normal CDF, and $\phi$ is the PDF.

\subsection{Black'76 Model (Lognormal Vol)}

For lognormal volatility quoting:
\begin{equation}
    V_{\text{call}} = \text{DF} \cdot \left[F\Phi(d_1) - K\Phi(d_2)\right]
\end{equation}
where:
\begin{align}
    d_1 &= \frac{\ln(F/K) + \frac{1}{2}\sigma_B^2 T}{\sigma_B\sqrt{T}} \\
    d_2 &= d_1 - \sigma_B\sqrt{T}
\end{align}

\subsection{Shifted Black'76}

For shifted lognormal with shift $\lambda$:
\begin{equation}
    V_{\text{call}} = \text{DF} \cdot \left[(F+\lambda)\Phi(d_1) - (K+\lambda)\Phi(d_2)\right]
\end{equation}
with $d_1, d_2$ computed using $\tilde{F} = F + \lambda$ and $\tilde{K} = K + \lambda$.

\subsection{Pricing Workflow}

The pricing workflow is:
\begin{equation}
    V = \text{BaseModel}(F_0, K, T, \sigma_{\text{imp}}(K; \text{SABR params}))
\end{equation}

\section{Instrument Pricing}

\subsection{Caplet Pricing}

A caplet pays $\delta \cdot \max(L(T_s, T_e) - K, 0)$ at time $T_e$, where $L$ is the LIBOR/SOFR rate.

\begin{equation}
    V_{\text{caplet}} = \delta \cdot \text{DF}(T_e) \cdot \text{Black/Bachelier}(F_0, K, T_s, \sigma_{\text{imp}}(K))
\end{equation}

where:
\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item $F_0 = \frac{1}{\delta}\left(\frac{P(0,T_s)}{P(0,T_e)} - 1\right)$ is the forward rate from curves
    \item $\delta = T_e - T_s$ is the day count fraction
    \item $\text{DF}(T_e) = P(0,T_e)$ is the discount factor from OIS curve
\end{itemize}

\subsection{Swaption Pricing}

A payer swaption gives the right to enter a swap paying fixed rate $K$:

\begin{equation}
    V_{\text{swaption}} = A(0) \cdot \text{Black/Bachelier}(S_0, K, T, \sigma_{\text{imp}}(K))
\end{equation}

where:
\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item $S_0$ is the forward swap rate
    \item $A(0) = \sum_{i=1}^{n} \delta_i P(0, T_i)$ is the annuity (PV01)
    \item $T$ is the option expiry
\end{itemize}

\section{Model-Consistent Risk}

\subsection{Delta with Smile-Dynamics Correction}

The model-consistent delta accounts for smile movement with the forward:
\begin{equation}
    \Delta_{\text{SABR}} = \frac{\partial V}{\partial F} + \frac{\partial V}{\partial \sigma_{\text{imp}}} \cdot \frac{\partial \sigma_{\text{imp}}}{\partial F}
\end{equation}

For Black'76 implied vol $\sigma_B$:
\begin{equation}
    \Delta_{\text{SABR}} = \Delta_{\text{Black}} + \mathcal{V}_{\text{Black}} \cdot \frac{\partial \sigma_B}{\partial F}
\end{equation}

where $\mathcal{V}_{\text{Black}} = \partial V / \partial \sigma_B$ is Black vega.

\subsection{Sideways vs Backbone Decomposition}

The total derivative $\partial \sigma_B / \partial F$ decomposes into:

\begin{equation}
    \frac{\partial \sigma_B}{\partial F} = \underbrace{\frac{\partial \sigma_B}{\partial F}\bigg|_{\sigma_{\text{ATM}}}}_\text{Sideways} + \underbrace{\frac{\partial \sigma_B}{\partial \sigma_{\text{ATM}}} \cdot \frac{\partial \sigma_{\text{ATM}}}{\partial F}}_\text{Backbone}
\end{equation}

\textbf{Sideways term:} Captures sticky-moneyness behavior---the smile slides along fixed ATM level as $k = \ln(F/K)$ changes.

\textbf{Backbone term:} Captures how ATM vol changes with forward level through the backbone relationship.

\textbf{Key insight:} When parameterizing by $\sigma_{\text{ATM}}$ and holding it fixed, the backbone term vanishes, leaving only sideways (sticky-log-moneyness-like) behavior.

\subsection{Vega, Vanna, and Volga}

\begin{definition}[Vega (Desk Definition)]
Vega with respect to $\sigma_{\text{ATM}}$:
\begin{equation}
    \mathcal{V}_{\sigma_{\text{ATM}}} = \frac{\partial V}{\partial \sigma_{\text{ATM}}} = \frac{\partial V}{\partial \sigma_B} \cdot \frac{\partial \sigma_B}{\partial \alpha} \cdot \frac{\partial \alpha}{\partial \sigma_{\text{ATM}}}
\end{equation}
\end{definition}

\begin{definition}[Vanna]
Sensitivity to correlation:
\begin{equation}
    \text{Vanna} = \frac{\partial V}{\partial \rho} = \frac{\partial V}{\partial \sigma_B} \cdot \frac{\partial \sigma_B}{\partial \rho}
\end{equation}
\end{definition}

\begin{definition}[Volga]
Sensitivity to vol-of-vol:
\begin{equation}
    \text{Volga} = \frac{\partial V}{\partial \nu} = \frac{\partial V}{\partial \sigma_B} \cdot \frac{\partial \sigma_B}{\partial \nu}
\end{equation}
\end{definition}

\subsection{Risk Report Output}

The risk report includes:
\begin{itemize}[leftmargin=1.2em,itemsep=0.1em]
    \item $\Delta_{\text{base}}$: Delta without smile adjustment
    \item $\Delta_{\text{SABR}}$: Model-consistent delta with smile dynamics
    \item $\mathcal{V}_{\sigma_{\text{ATM}}}$: Vega w.r.t.\ ATM vol
    \item Vanna: $\partial V / \partial \rho$
    \item Volga: $\partial V / \partial \nu$
    \item Gamma, Theta (standard)
\end{itemize}

\section{Testing and Validation}

\subsection{Required Unit Tests}

\begin{enumerate}[leftmargin=1.2em,itemsep=0.1em]
    \item \textbf{Calibration test:} Fitted implied vols reprice market quotes within tolerance across all strikes.
    \item \textbf{Greeks test:} Analytic SABR risk matches finite-difference bumps for $F$ and all parameters.
    \item \textbf{Shift test:} With \code{shift} $> 0$, shifted-lognormal pricing is stable for near-zero and negative forwards.
    \item \textbf{$\sigma_{\text{ATM}}$ parameterization test:} Keeping $\sigma_{\text{ATM}}$ fixed removes backbone sensitivity from delta.
\end{enumerate}

\subsection{Demo Script}

Provide \code{scripts/run\_sabr\_demo.py} that:
\begin{enumerate}[leftmargin=1.2em,itemsep=0.1em]
    \item Builds OIS and projection curves
    \item Loads \code{vol\_quotes.csv}
    \item Calibrates SABR parameters
    \item Prices a caplet or swaption
    \item Prints a risk report comparing $\Delta_{\text{base}}$ vs $\Delta_{\text{SABR}}$, plus vega/vanna/volga
\end{enumerate}

%===============================================================================
% CHAPTER 10: INTERACTIVE DASHBOARD
%===============================================================================
\chapter{Interactive Dashboard}

\section{Overview}

The library includes a comprehensive Streamlit dashboard (\code{dashboard/interactive\_dashboard.py}) providing full visualization and interaction with all library functionality.

\subsection{Launching the Dashboard}

\begin{lstlisting}[language=bash]
cd dashboard
streamlit run interactive_dashboard.py

# Or use the launcher scripts
# Windows:
launch_interactive.bat

# Linux/Mac:
bash launch_interactive.sh
\end{lstlisting}

\section{Dashboard Tabs}

\subsection{Tab 1: Curves}

\textbf{Features:}
\begin{itemize}
    \item Market snapshot with NSS and SABR parameters
    \item OIS curve bootstrap from market quotes
    \item Treasury NSS fitting with parameter display
    \item Side-by-side curve comparison plots
    \item Discount factor and forward rate visualization
    \item SABR volatility surface display
    \item Implied vol curves by bucket with smile visualization
    \item ATM volatility surface heatmap
    \item Bucket fallback diagnostics
\end{itemize}

\subsection{Tab 2: Pricing}

\textbf{Bond Pricer:}
\begin{itemize}
    \item User-selectable day count convention (ACT/360, ACT/365, ACT/ACT, 30/360)
    \item Maturity date, coupon rate, payment frequency inputs
    \item Outputs: dirty price, clean price, accrued interest, DV01
\end{itemize}

\textbf{Swap Pricer:}
\begin{itemize}
    \item Maturity, fixed rate, notional, direction (PAY/RECEIVE)
    \item Outputs: present value, DV01, par rate
\end{itemize}

\textbf{Futures Pricer:}
\begin{itemize}
    \item Expiry date, number of contracts
    \item Outputs: theoretical price, implied rate, DV01
\end{itemize}

\textbf{Options (SABR):}
\begin{itemize}
    \item Swaption pricing with calibrated SABR surface
    \item Expiry and tenor selection from available buckets
    \item Strike offset slider (-200bp to +200bp)
    \item Outputs: PV, forward swap rate, implied vol
    \item SABR bucket diagnostics table
    \item Full risk report with Greeks
\end{itemize}

\subsection{Tab 3: Risk Metrics}

\textbf{Portfolio Risk Summary:}
\begin{itemize}
    \item Real bump-and-reprice DV01 computation
    \item Coverage ratio warnings (linear vs full portfolio)
    \item Failed trade diagnostics with expandable details
    \item Total PV, total DV01, instrument count
\end{itemize}

\textbf{Key-Rate DV01 Analysis:}
\begin{itemize}
    \item Computed via localized tenor bumps (not equal-split)
    \item Interactive bar chart visualization
    \item Detail table with \$/bp units
    \item Worst key-rate identification
\end{itemize}

\textbf{SABR Calibration Diagnostics:}
\begin{itemize}
    \item Parameters by bucket (sigma\_atm, nu, rho, beta)
    \item Fit quality metrics (RMSE, max absolute error)
    \item Fallback usage tracking
\end{itemize}

\textbf{Risk Limits:}
\begin{itemize}
    \item Real-time limit evaluation against DEFAULT\_LIMITS
    \item Traffic light status (PASS/WARN/FAIL/NOT\_COMPUTED)
    \item Conditional checks based on portfolio composition
    \item Integration with VaR results from Tab 4
\end{itemize}

\subsection{Tab 4: VaR Analysis}

\textbf{VaR Methods:}
\begin{itemize}
    \item Historical Simulation (lookback: 30-252 days)
    \item Monte Carlo (1,000-20,000 paths)
    \item Stressed VaR (COVID\_2020, RATE\_HIKE\_2022, TAPER\_2013, GFC\_2008)
\end{itemize}

\textbf{Option Inclusion Toggle:}
\begin{itemize}
    \item Full repricing (slower, accurate) vs linear-only (fast)
    \item Coverage warnings when options excluded
    \item Per-instrument failure tracking
\end{itemize}

\textbf{Outputs:}
\begin{itemize}
    \item VaR at 95\%, 99\%, 99.5\% confidence
    \item Expected Shortfall (ES) at 97.5\%
    \item Distribution histogram with VaR lines
    \item Scenario P\&L breakdown table
    \item Results persisted to session state for limit checks
\end{itemize}

\subsection{Tab 5: Scenarios}

\textbf{Standard Curve Scenarios:}
\begin{itemize}
    \item Parallel shifts (+100bp, -100bp, +200bp, -200bp)
    \item Steepeners and flatteners (2s10s, 5s30s)
    \item Twists (butterfly, barbell)
    \item Bear/bull scenarios
\end{itemize}

\textbf{Vol-Only Scenarios:}
\begin{itemize}
    \item Curve unchanged; SABR parameters shocked and portfolio repriced
    \item Vol Shock +50\% (ATM volatility up across buckets)
    \item Vol Shock -30\% (ATM volatility down across buckets)
    \item $\nu$ Stress +100\% (vol-of-vol doubled)
    \item $\rho$ Stress -0.5 (more negative skew)
    \item Crisis Vol (combined vol + smile stress)
    \item Reported as options P\&L vs linear P\&L (linear should be near zero)
\end{itemize}

\textbf{SABR Tail Stress:}
\begin{itemize}
    \item $\nu$ stress tested via multipliers (baseline, +50\%, +100\%)
    \item $\rho$ stress tested via shifts (baseline, -0.25, -0.50)
    \item Option PV changes are repriced; ES figures are reported as a tail-risk estimate derived from the $\nu$ stress
\end{itemize}

\textbf{Outputs:}
\begin{itemize}
    \item Scenario P\&L table sorted by loss
    \item Bar chart visualization
    \item Worst scenario identification
    \item Combined curve+vol additivity check (curve P\&L + vol P\&L); full joint repricing is a future enhancement
\end{itemize}

\subsection{Tab 6: P\&L Attribution}

\textbf{Linear Products Attribution (illustrative):}
\begin{itemize}
    \item Example decomposition into carry, rolldown, curve moves (parallel/non-parallel), convexity, and residual
    \item Bar chart visualization and summary metrics (realized vs predicted vs residual)
\end{itemize}

\textbf{Options P\&L Attribution (Greeks-based):}
\begin{itemize}
    \item Greeks-based decomposition: Delta P\&L, Vega P\&L, Gamma P\&L, Vanna P\&L, Volga P\&L, Theta P\&L
    \item Aggregated across option positions with portfolio Greeks summary
    \item Uses actual SABR-calibrated Greeks (no hardcoding)
\end{itemize}

\textbf{Inputs:}
\begin{itemize}
    \item Rate move in bp (input: -100bp to +100bp)
    \item Vol move in bp (input: -100bp to +100bp)
    \item Days passed (input: 0-30 days, for theta)
\end{itemize}

\subsection{Tab 7: Liquidity Risk}

\textbf{Liquidity-Adjusted VaR (LVaR):}
\begin{itemize}
    \item Bid-ask spread inputs by instrument type
    \item Holding period scaling (square-root-of-time)
    \item Simplified liquidation cost proxy based on portfolio DV01 and spreads
    \item LVaR computed as a combined risk measure (VaR + liquidity adjustment), with breakdown visualization
    \item Uplift calculation and visualization
\end{itemize}

\textbf{Liquidity Metrics:}
\begin{itemize}
    \item Reference spreads and estimated liquidation times by instrument type
\end{itemize}

\subsection{Tab 8: Data Explorer}

\textbf{Features:}
\begin{itemize}
    \item Market quotes tables (OIS and Treasury)
    \item Portfolio positions table with CSV download
    \item Historical rates preview
    \item Curve nodes inspection (dates, discount factors, zero rates)
\end{itemize}

\section{Dashboard Architecture}

\subsection{Data Loading with Caching}

\begin{lstlisting}
@st.cache_data
def load_ois_quotes():
    return pd.read_csv('data/sample_quotes/ois_quotes.csv')

@st.cache_data
def load_positions():
    return pd.read_csv('data/sample_book/positions.csv', comment='#')
\end{lstlisting}

\subsection{Market State Construction}

\begin{lstlisting}
def build_market_state(ois_curve, projection_curve, 
                       valuation_date, vol_quotes_df):
    curve_state = CurveState(
        discount_curve=ois_curve,
        projection_curve=projection_curve,
        metadata={"valuation_date": str(valuation_date)},
    )
    
    # Normalize vol quotes (requires curve_state)
    normalized = normalize_vol_quotes(vol_quotes_df, curve_state)
    
    # Build SABR surface
    sabr_surface = build_sabr_surface(normalized, curve_state, beta_policy=0.5)
    
    # Create market state
    return MarketState(curve=curve_state, sabr_surface=sabr_surface, asof=str(valuation_date)), normalized
\end{lstlisting}

\subsection{Session State for Cross-Tab Communication}

The dashboard uses \code{st.session\_state} to share results between tabs:

\begin{lstlisting}
# In VaR tab: store results
st.session_state['var_results'] = {
    'var_95': var_95,
    'var_99': var_99,
    'es_975': es_975
}

# In Risk Limits tab: retrieve
var_state = st.session_state.get('var_results')
if var_state:
    metrics['var_95'] = var_state['var_95']
\end{lstlisting}

%===============================================================================
% CHAPTER 11: API REFERENCE
%===============================================================================
\chapter{API Reference}

\section{Conventions Module}

\subsection{DayCount Enum}

\begin{lstlisting}
class DayCount(Enum):
    ACT_360 = "ACT/360"
    ACT_365 = "ACT/365"
    ACT_ACT = "ACT/ACT"
    THIRTY_360 = "30/360"
    
    @classmethod
    def from_string(cls, s: str) -> "DayCount"
\end{lstlisting}

\subsection{Conventions Dataclass}

\begin{lstlisting}
@dataclass
class Conventions:
    day_count: DayCount = DayCount.ACT_360
    business_day: BusinessDayConvention = BusinessDayConvention.MODIFIED_FOLLOWING
    compounding: CompoundingConvention = CompoundingConvention.CONTINUOUS
    payment_frequency: int = 1
    settlement_days: int = 2
    
    @classmethod
    def usd_ois(cls) -> "Conventions"
    
    @classmethod
    def usd_treasury(cls) -> "Conventions"
    
    @classmethod
    def usd_swap(cls) -> "Conventions"
\end{lstlisting}

\subsection{year\_fraction Function}

\begin{lstlisting}
def year_fraction(
    start: date, 
    end: date, 
    day_count: DayCount
) -> float
\end{lstlisting}

\section{Curves Module}

\subsection{Curve Class}

\begin{lstlisting}
class Curve:
    def __init__(
        self,
        anchor_date: date,
        currency: str = "USD",
        day_count: DayCount = DayCount.ACT_365,
        interpolation_method: str = "cubic_spline"
    )
    
    def add_node(self, time: float, discount_factor: float) -> None
    def add_node_from_date(self, d: date, discount_factor: float) -> None
    def build(self) -> None
    def discount_factor(self, t: Union[float, date]) -> float
    def zero_rate(self, t: Union[float, date], 
                  compounding: CompoundingConvention = ...) -> float
    def forward_rate(self, t1: float, t2: float) -> float
    def bump_parallel(self, bp: float) -> "Curve"
    def bump_tenor(self, tenor: str, bp: float) -> "Curve"
    def copy(self) -> "Curve"
\end{lstlisting}

\subsection{OISBootstrapper Class}

\begin{lstlisting}
class OISBootstrapper:
    def __init__(
        self,
        anchor_date: date,
        day_count: DayCount = DayCount.ACT_360,
        tolerance: float = 1e-8,
        interpolation_method: str = "cubic_spline"
    )
    
    def bootstrap(
        self,
        instruments: List[CurveInstrument],
        verify: bool = True
    ) -> BootstrapResult
\end{lstlisting}

\subsection{NelsonSiegelSvensson Class}

\begin{lstlisting}
class NelsonSiegelSvensson:
    def __init__(
        self,
        anchor_date: date,
        day_count: DayCount = DayCount.ACT_ACT
    )
    
    def fit(
        self,
        maturities: List[float],
        yields: List[float],
        weights: Optional[List[float]] = None,
        initial_guess: Optional[NSSParameters] = None,
        method: str = "L-BFGS-B"
    ) -> Tuple[float, np.ndarray]
    
    def fit_from_par_yields(
        self,
        tenors: List[str],
        par_yields: List[float],
        weights: Optional[List[float]] = None
    ) -> Tuple[float, np.ndarray]
    
    def yield_at(self, tau: Union[float, date]) -> float
    def discount_factor(self, tau: Union[float, date]) -> float
    def forward_rate(self, t1: float, t2: float) -> float
    def instantaneous_forward(self, tau: float) -> float
    def to_curve(self, tenors: List[float] = None) -> Curve
\end{lstlisting}

\section{Pricers Module}

\subsection{BondPricer Class}

\begin{lstlisting}
class BondPricer:
    def __init__(
        self,
        curve: Curve,
        conventions: Optional[Conventions] = None
    )
    
    def price(
        self,
        settlement: date,
        maturity: date,
        coupon_rate: float,
        face_value: float = 100.0,
        frequency: int = 2
    ) -> Tuple[float, float, float]  # (dirty, clean, accrued)
    
    def generate_cashflows(
        self,
        settlement: date,
        maturity: date,
        coupon_rate: float,
        face_value: float = 100.0,
        frequency: int = 2
    ) -> BondCashflows
    
    def compute_dv01(
        self,
        settlement: date,
        maturity: date,
        coupon_rate: float,
        face_value: float = 100.0,
        bump_size: float = 1.0
    ) -> float
\end{lstlisting}

\subsection{SwapPricer Class}

\begin{lstlisting}
class SwapPricer:
    def __init__(
        self,
        discount_curve: Curve,
        projection_curve: Optional[Curve] = None,
        fixed_conventions: Optional[Conventions] = None,
        float_conventions: Optional[Conventions] = None
    )
    
    def present_value(
        self,
        effective: date,
        maturity: date,
        notional: float,
        fixed_rate: float,
        pay_receive: str = "PAY"
    ) -> float
    
    def par_rate(
        self,
        effective: date,
        maturity: date
    ) -> float
    
    def generate_cashflows(
        self,
        effective: date,
        maturity: date,
        notional: float,
        fixed_rate: float,
        pay_receive: str = "PAY"
    ) -> SwapCashflows
\end{lstlisting}

\section{Risk Module}

\subsection{BumpEngine Class}

\begin{lstlisting}
class BumpEngine:
    def __init__(self, base_curve: Curve)
    
    def parallel_bump(self, bp: float) -> Curve
    def node_bump(self, node_index: int, bp: float) -> Curve
    def tenor_bump(self, tenor: str, bp: float) -> Curve
    def custom_bump(self, bump_vector: Dict[str, float]) -> Curve
    
    def compute_dv01(
        self,
        pricer_func: Callable[[Curve], float],
        bump_size: float = 1.0
    ) -> float
    
    def compute_convexity(
        self,
        pricer_func: Callable[[Curve], float],
        bump_size: float = 1.0
    ) -> float
\end{lstlisting}

\subsection{KeyRateEngine Class}

\begin{lstlisting}
class KeyRateEngine:
    def __init__(
        self,
        curve: Curve,
        tenors: Optional[List[str]] = None,
        bump_size: float = 1.0,
        interpolate_bumps: bool = False
    )
    
    def compute_key_rate_dv01(
        self,
        pricer_func: Callable[[Curve], float]
    ) -> KeyRateDV01
\end{lstlisting}

\subsection{RiskCalculator Class}

\begin{lstlisting}
class RiskCalculator:
    def __init__(
        self,
        curve: Curve,
        bump_size: float = 1.0
    )
    
    def compute_bond_risk(
        self,
        instrument_id: str,
        settlement: date,
        maturity: date,
        coupon_rate: float,
        notional: float,
        frequency: int = 2
    ) -> InstrumentRisk
    
    def compute_swap_risk(
        self,
        instrument_id: str,
        effective: date,
        maturity: date,
        notional: float,
        fixed_rate: float,
        pay_receive: str = "PAY"
    ) -> InstrumentRisk
\end{lstlisting}

\section{VaR Module}

\subsection{HistoricalSimulation Class}

\begin{lstlisting}
class HistoricalSimulation:
    def __init__(
        self,
        base_curve: Curve,
        historical_data: pd.DataFrame,
        pricer_func: Callable[[Curve], float],
        tenors: Optional[List[str]] = None
    )
    
    def run_simulation(
        self,
        lookback_days: Optional[int] = None
    ) -> HistoricalVaRResult
\end{lstlisting}

\subsection{MonteCarloVaR Class}

\begin{lstlisting}
class MonteCarloVaR:
    def __init__(
        self,
        base_curve: Curve,
        historical_data: pd.DataFrame,
        pricer_func: Callable[[Curve], float],
        tenors: Optional[List[str]] = None
    )
    
    def simulate_scenarios(
        self,
        num_paths: int = 10000,
        seed: Optional[int] = None
    ) -> np.ndarray
    
    def run_simulation(
        self,
        num_paths: int = 10000,
        seed: Optional[int] = 42
    ) -> MonteCarloResult
\end{lstlisting}

\subsection{ScenarioEngine Class}

\begin{lstlisting}
class ScenarioEngine:
    def __init__(
        self,
        base_curve: Curve,
        pricer_func: Callable[[Curve], float],
        key_rate_dv01: Optional[Dict[str, float]] = None
    )
    
    def run_scenario(self, scenario: Scenario) -> ScenarioResult
    
    def run_all_scenarios(
        self,
        scenarios: Optional[Dict[str, Scenario]] = None
    ) -> List[ScenarioResult]
\end{lstlisting}

\section{Portfolio Module}

\subsection{Trade Builders}

\begin{lstlisting}
def build_bond_trade(pos: pd.Series, valuation_date: date) -> Dict[str, Any]:
    """Build validated bond trade from a position row."""

def build_swap_trade(pos: pd.Series, valuation_date: date) -> Dict[str, Any]:
    """Build validated swap trade from a position row."""

def build_swaption_trade(pos: pd.Series, valuation_date: date) -> Dict[str, Any]:
    """Build validated swaption trade from a position row."""

def build_caplet_trade(pos: pd.Series, valuation_date: date) -> Dict[str, Any]:
    """Build validated caplet trade from a position row."""

def build_trade_from_position(
    pos: pd.Series,
    valuation_date: date,
    allow_legacy_options: bool = False
) -> Dict[str, Any]:
    """Dispatch to the correct builder based on instrument_type."""
\end{lstlisting}

\subsection{Portfolio Pricing}

\begin{lstlisting}
@dataclass
class PortfolioPricingResult:
    total_pv: float
    successful_trades: List[Dict[str, Any]]
    successful_pvs: List[float]
    failed_trades: List[TradeFailure]
    total_positions: int
    
    @property
    def successful_count(self) -> int: ...
    
    @property
    def failed_count(self) -> int: ...
    
    @property
    def coverage_ratio(self) -> float: ...
    
    @property
    def has_failures(self) -> bool: ...

def price_portfolio_with_diagnostics(
    positions_df: pd.DataFrame,
    market_state: MarketState,
    valuation_date: date,
    include_options: bool = True,
    allow_legacy_options: bool = False
) -> PortfolioPricingResult:
    """Price portfolio with comprehensive diagnostics."""
\end{lstlisting}

\subsection{Exception Types}

\begin{lstlisting}
class PositionValidationError(Exception):
    """Base exception for position validation failures."""

class MissingFieldError(PositionValidationError):
    """Required field missing from position."""

class InvalidOptionError(PositionValidationError):
    """Option parameters are invalid or incomplete."""
\end{lstlisting}

\section{Market State Module}

\subsection{MarketState Class}

\begin{lstlisting}
@dataclass
class MarketState:
    curve: CurveState
    sabr_surface: Optional[SabrSurfaceState] = None
    asof: Any = field(default_factory=datetime.utcnow)
    
    def get_sabr_params(
        self,
        expiry: str,
        tenor: str,
        allow_fallback: bool = True
    ) -> Optional[SabrBucketParams]: ...
\end{lstlisting}

\subsection{CurveState Class}

\begin{lstlisting}
@dataclass
class CurveState:
    discount_curve: Curve
    projection_curve: Optional[Curve] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if self.projection_curve is None:
            self.projection_curve = self.discount_curve
\end{lstlisting}

\section{Volatility Module}

\subsection{SabrParams Dataclass}

\begin{lstlisting}
@dataclass
class SabrParams:
    """SABR model parameters.
    
    Attributes:
        sigma_atm: ATM implied volatility (calibration input)
        beta: CEV exponent (typically fixed, 0 <= beta <= 1)
        rho: Correlation between forward and vol (-1 < rho < 1)
        nu: Volatility of volatility (vol-of-vol)
        shift: Shift for negative rates (default 0)
    """
    sigma_atm: float
    beta: float
    rho: float
    nu: float
    shift: float = 0.0
    
    def to_dict(self) -> Dict[str, float]
    
    @classmethod
    def from_dict(cls, d: Dict[str, float]) -> "SabrParams"
\end{lstlisting}

\subsection{SabrModel Class}

\begin{lstlisting}
class SabrModel:
    """SABR stochastic volatility model.
    
    Implements Hagan et al. approximation for implied volatility
    and provides methods for calibration and risk computation.
    """
    
    def implied_vol_black(
        self,
        F: float,
        K: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Compute Black'76 implied vol using Hagan approximation."""
    
    def implied_vol_normal(
        self,
        F: float,
        K: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Compute Bachelier (normal) implied vol."""
    
    def alpha_from_sigma_atm(
        self,
        F: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Invert ATM formula to get alpha from sigma_atm."""
    
    def dalpha_dsigma_atm(
        self,
        F: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Derivative of alpha w.r.t. sigma_atm (for vega)."""
    
    def dsigma_dF(
        self,
        F: float,
        K: float,
        T: float,
        params: SabrParams,
        hold_atm_fixed: bool = True
    ) -> float:
        """Derivative of implied vol w.r.t. forward.
        
        If hold_atm_fixed=True, returns only sideways component.
        Otherwise includes backbone effect.
        """
    
    def dsigma_drho(
        self,
        F: float,
        K: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Derivative of implied vol w.r.t. rho (for vanna)."""
    
    def dsigma_dnu(
        self,
        F: float,
        K: float,
        T: float,
        params: SabrParams
    ) -> float:
        """Derivative of implied vol w.r.t. nu (for volga)."""
\end{lstlisting}

\subsection{SabrSurfaceState Class}

\begin{lstlisting}
@dataclass
class SabrSurfaceState:
    """SABR volatility surface with bucket-wise parameters.
    
    Attributes:
        params_by_bucket: Dict mapping (expiry, tenor) to SabrBucketParams
        missing_bucket_policy: "nearest" or "wildcard"
        diagnostics: Calibration diagnostics per bucket
    """
    params_by_bucket: Dict[BucketKey, SabrBucketParams]
    diagnostics: Dict[str, Any] = field(default_factory=dict)
    convention: Dict[str, Any] = field(default_factory=dict)
    asof: Optional[str] = None
    missing_bucket_policy: str = "nearest"
    
    def get_bucket_params(
        self,
        expiry: str,
        tenor: str,
        allow_fallback: bool = True
    ) -> Optional[SabrBucketParams]:
        """Retrieve parameters for bucket.
        
        Lookup order:
        1. Exact match (expiry, tenor)
        2. Wildcard ("ALL", "ALL") if present
        3. Nearest neighbor (if allow_fallback=True)
        
        The wildcard bucket is skipped during nearest-neighbor
        distance calculations to avoid tenor parsing errors.
        """
    
    def diagnostics_table(self) -> Dict[BucketKey, Dict[str, Any]]:
        """Return diagnostics keyed by bucket for reporting."""
\end{lstlisting}

\subsection{SabrBucketParams Dataclass}

\begin{lstlisting}
@dataclass
class SabrBucketParams:
    """SABR parameters for a single (expiry, tenor) bucket."""
    sigma_atm: float
    beta: float
    rho: float
    nu: float
    shift: float = 0.0
    diagnostics: Dict[str, Any] = field(default_factory=dict)
    
    def to_sabr_params(self) -> SabrParams:
        """Convert to SabrParams for risk engine."""
        return SabrParams(
            sigma_atm=self.sigma_atm,
            beta=self.beta,
            rho=self.rho,
            nu=self.nu,
            shift=self.shift
        )
\end{lstlisting}

\subsection{SabrCalibrator Class}

\begin{lstlisting}
class SabrCalibrator:
    """Calibrator for SABR parameters from market vol quotes."""
    
    def __init__(
        self,
        beta: float = 0.5,
        use_sigma_atm_param: bool = True
    ):
        """Initialize calibrator.
        
        Args:
            beta: Fixed CEV exponent (typically 0, 0.5, or 1)
            use_sigma_atm_param: If True, parameterize by sigma_atm
        """
    
    def fit(
        self,
        quotes_df: pd.DataFrame,
        F: float,
        T: float,
        shift: float = 0.0,
        vol_type: str = "NORMAL"
    ) -> CalibrationResult:
        """Fit SABR parameters to market vol quotes.
        
        Args:
            quotes_df: DataFrame with columns [strike, vol] or
                [strike, vol, weight] for weighted calibration
            F: Forward rate
            T: Time to expiry in years
            shift: Shift for negative rates
            vol_type: "NORMAL" or "LOGNORMAL" for quote convention
            
        Returns:
            CalibrationResult with fitted params, error, and diagnostics
        """
    
    def fit_error(
        self,
        params: SabrParams,
        quotes_df: pd.DataFrame,
        F: float,
        T: float
    ) -> float:
        """Compute calibration error (sum of squared vol differences)."""


@dataclass
class CalibrationResult:
    """Result of SABR calibration."""
    params: SabrParams          # Calibrated parameters
    fit_error: float            # Total fit error
    vol_errors: Dict[float, float]  # {strike: error}
    success: bool               # Whether calibration converged
    message: str                # Status message
\end{lstlisting}

\section{Options Module}

\subsection{CapletPricer Class}

\begin{lstlisting}
class CapletPricer:
    """Caplet pricing engine.
    
    Prices caplets using Bachelier or Black'76 model
    with implied vol from SABR or direct input.
    """
    
    def __init__(
        self,
        discount_curve: Curve,
        projection_curve: Optional[Curve] = None
    )
    
    def forward_rate(
        self,
        start: float,
        end: float
    ) -> float:
        """Compute forward rate for period [start, end]."""
    
    def price(
        self,
        F: float,
        K: float,
        T: float,
        df: float,
        vol: float,
        vol_type: str = "NORMAL",
        notional: float = 1.0,
        delta_t: float = 0.25,
        is_cap: bool = True,
        shift: float = 0.0
    ) -> float:
        """Price a caplet or floorlet.
        
        Args:
            F: Forward rate
            K: Strike rate
            T: Time to expiry (option expiry)
            df: Discount factor to payment
            vol: Implied volatility
            vol_type: "NORMAL" or "LOGNORMAL"
            notional: Notional amount
            delta_t: Accrual period (T_end - T_start)
            is_cap: True for caplet, False for floorlet
            shift: Shift for shifted lognormal
            
        Returns:
            Caplet/floorlet price
        """
    
    def greeks(
        self,
        F: float,
        K: float,
        T: float,
        df: float,
        vol: float,
        vol_type: str = "NORMAL",
        notional: float = 1.0,
        delta_t: float = 0.25,
        is_cap: bool = True
    ) -> Dict[str, float]:
        """Compute caplet Greeks.
        
        Returns:
            Dict with delta, gamma, vega, theta
        """
    
    def price_with_sabr(
        self,
        expiry: date,
        tenor: str,
        K: float,
        sabr_params: SabrParams,
        vol_type: str = "NORMAL",
        notional: float = 1.0
    ) -> float:
        """Price caplet using SABR implied vol."""
\end{lstlisting}

\subsection{SwaptionPricer Class}

\begin{lstlisting}
class SwaptionPricer:
    """Swaption pricing engine."""
    
    def __init__(
        self,
        discount_curve: Curve,
        projection_curve: Optional[Curve] = None,
        fixed_freq: int = 2,
        float_freq: int = 4
    ):
        """Initialize swaption pricer.
        
        Args:
            discount_curve: OIS curve for discounting
            projection_curve: Curve for forward rates
            fixed_freq: Fixed leg frequency (2 = semi-annual)
            float_freq: Float leg frequency (4 = quarterly)
        """
    
    def forward_swap_rate(
        self,
        expiry: float,
        tenor: float
    ) -> Tuple[float, float]:
        """Compute forward swap rate and annuity.
        
        Args:
            expiry: Time to option expiry (years)
            tenor: Swap tenor from expiry (years)
            
        Returns:
            Tuple of (forward_rate, annuity)
        """
    
    def price(
        self,
        S: float,
        K: float,
        T: float,
        annuity: float,
        vol: float,
        vol_type: str = "NORMAL",
        payer_receiver: str = "PAYER",
        notional: float = 1.0,
        shift: float = 0.0
    ) -> float:
        """Price a swaption.
        
        Args:
            S: Forward swap rate
            K: Strike rate
            T: Time to expiry
            annuity: Swap annuity (PV01)
            vol: Implied volatility
            vol_type: "NORMAL" or "LOGNORMAL"
            payer_receiver: "PAYER" or "RECEIVER"
            notional: Notional amount
            shift: Shift for shifted lognormal
            
        Returns:
            Swaption price
        """
\end{lstlisting}

\subsection{SabrOptionRisk Class}

\begin{lstlisting}
class SabrOptionRisk:
    """SABR model-consistent risk calculator.
    
    Computes Greeks with smile-dynamics corrections.
    """
    
    def __init__(
        self,
        vol_type: str = "NORMAL"
    ):
        """Initialize risk engine.
        
        Args:
            vol_type: "NORMAL" or "LOGNORMAL" for base model
        """
    
    def risk_report(
        self,
        F: float,
        K: float,
        T: float,
        sabr_params: SabrParams,
        annuity: float = 1.0,
        is_call: bool = True,
        notional: float = 1.0
    ) -> RiskReport:
        """Generate comprehensive risk report.
        
        Args:
            F: Forward rate
            K: Strike rate
            T: Time to expiry (years)
            sabr_params: Calibrated SABR parameters
            annuity: Discount factor / annuity
            is_call: True for call/payer, False for put/receiver
            notional: Notional amount
            
        Returns:
            RiskReport with all risk metrics
        """
    
    def delta_decomposition(
        self,
        F: float,
        K: float,
        T: float,
        sabr_params: SabrParams,
        annuity: float = 1.0,
        is_call: bool = True
    ) -> Dict[str, float]:
        """Decompose delta into components.
        
        Returns:
            Dict with:
            - delta_base: dV/dF at fixed vol
            - delta_sideways: Smile adjustment (sticky moneyness)
            - delta_backbone: ATM level effect (zero if sigma_atm fixed)
            - delta_total: Sum of all components
        """


@dataclass
class RiskReport:
    """Container for SABR option risk metrics."""
    
    # Basic Greeks
    delta_base: float        # Delta without smile adjustment
    delta_sabr: float        # Model-consistent delta
    gamma_base: float        # Base gamma
    vega_atm: float          # Vega to ATM vol shift
    
    # Higher-order vol Greeks
    vanna: float             # dDelta/dVol
    volga: float             # dVega/dVol
    
    # Delta decomposition
    delta_sideways: float    # Delta with fixed smile
    delta_backbone: float    # Contribution from smile dynamics
    
    # Market data
    forward: float
    strike: float
    expiry: float
    implied_vol: float
    vol_type: str
    sabr_params: SabrParams
    
    def to_dict(self) -> Dict[str, float]
\end{lstlisting}

%===============================================================================
% APPENDICES
%===============================================================================
\section{P\&L Attribution Module}

\subsection{Options Greeks Attribution}

\begin{lstlisting}
@dataclass
class OptionsGreeksAttribution:
    """P&L attribution for a single option position."""
    instrument_id: str
    delta_pnl: float
    vega_pnl: float
    gamma_pnl: float
    vanna_pnl: float
    volga_pnl: float
    theta_pnl: float
    residual: float
    total_pnl: float
    delta: float
    gamma: float
    vega: float
    vanna: float
    volga: float
    rate_move_bp: float
    vol_move_bp: float
    days_passed: int

def compute_option_pnl_attribution(
    positions_df: pd.DataFrame,
    market_state: MarketState,
    valuation_date: date,
    rate_move_bp: float = 10.0,
    vol_move_bp: float = 20.0,
    days_passed: int = 1
) -> List[OptionsGreeksAttribution]:
    """Compute P&L attribution for option positions.
    
    Uses SABR-calibrated Greeks to decompose P&L into:
    - Delta P&L: from rate moves
    - Vega P&L: from vol moves
    - Gamma P&L: convexity effect
    - Vanna P&L: cross-effect (rate  vol)
    - Volga P&L: vol convexity
    - Theta P&L: time decay
    """

def aggregate_options_attribution(
    attributions: List[OptionsGreeksAttribution]
) -> Dict[str, float]:
    """Aggregate options P&L attribution across positions.
    
    Returns:
        Dict with:
        - delta_pnl, vega_pnl, gamma_pnl, etc.
        - total_pnl: sum of all components
        - position_count: number of positions
        - total_delta, total_gamma, total_vega: aggregated Greeks
    """
\end{lstlisting}

\subsection{Curve vs Vol Attribution}

\begin{lstlisting}
def attribute_curve_vs_vol(
    positions_df: pd.DataFrame,
    market_state_t0: MarketState,
    market_state_t1: MarketState,
    valuation_date_t0: date,
    valuation_date_t1: date
) -> Dict[str, float]:
    """Decompose P&L into curve and vol components.
    
    Returns:
        Dict with:
        - total_pnl: actual P&L
        - curve_pnl: P&L from curve moves (vol held constant)
        - vol_pnl: P&L from vol changes (curve held constant)
        - theta_pnl: time decay
        - residual: unexplained
    """
\end{lstlisting}

\section{Risk Reporting Module}

\subsection{Coverage Metrics}

\begin{lstlisting}
@dataclass
class VaRCoverageInfo:
    """Coverage information for VaR calculation."""
    total_instruments: int
    priced_instruments: int
    coverage_ratio: float
    is_linear_only: bool
    excluded_types: List[str]
    warnings: List[str]
    
    def has_warnings(self) -> bool:
        return len(self.warnings) > 0

def build_var_portfolio_pricer(
    positions_df: pd.DataFrame,
    valuation_date: date,
    market_state: MarketState,
    include_options: bool = True
) -> Tuple[Callable[[Curve], float], VaRCoverageInfo]:
    """Build portfolio pricer with coverage diagnostics.
    
    Returns:
        Tuple of (pricer_func, coverage_info)
        - pricer_func: Callable that takes a curve and returns PV
        - coverage_info: Diagnostics about what was included/excluded
    """
\end{lstlisting}

\subsection{Curve Risk Metrics}

\begin{lstlisting}
@dataclass
class CurveRiskMetrics:
    """Comprehensive curve risk metrics."""
    base_pv: float
    total_dv01: float
    keyrate_dv01: Dict[str, float]
    worst_keyrate_dv01: float
    instrument_coverage: int
    total_instruments: int
    coverage_ratio: float
    excluded_types: List[str]
    warnings: List[str]
    failed_trades: List[TradeFailure]
    
    @property
    def has_failures(self) -> bool:
        return len(self.failed_trades) > 0
    
    def to_dataframe(self) -> pd.DataFrame:
        """Convert key-rate DV01 to DataFrame."""

def compute_curve_risk_metrics(
    positions_df: pd.DataFrame,
    market_state: MarketState,
    valuation_date: date,
    keyrate_tenors: List[str],
    bump_bp: float = 1.0
) -> CurveRiskMetrics:
    """Compute portfolio risk using real bump-and-reprice."""
\end{lstlisting}

\appendix

\chapter{Mathematical Derivations}

\section{Duration and Convexity}

\subsection{Macaulay Duration}

For a bond with cashflows $C_i$ at times $t_i$:
\begin{equation}
    D_{\text{Mac}} = \frac{\sum_{i=1}^{n} t_i \cdot C_i \cdot e^{-y t_i}}{\sum_{i=1}^{n} C_i \cdot e^{-y t_i}} = \frac{\sum_{i=1}^{n} t_i \cdot \pv(C_i)}{\pv}
\end{equation}

\subsection{Modified Duration}

\begin{equation}
    D_{\text{Mod}} = \frac{D_{\text{Mac}}}{1 + y/m}
\end{equation}

where $m$ is the compounding frequency.

\subsection{Dollar Duration}

\begin{equation}
    \text{Dollar Duration} = D_{\text{Mod}} \times \pv
\end{equation}

\subsection{DV01 Derivation}

\begin{equation}
    \text{DV01} = \frac{\text{Dollar Duration}}{10{,}000} = \frac{D_{\text{Mod}} \times \pv}{10{,}000}
\end{equation}

\section{Nelson-Siegel-Svensson Derivation}

\subsection{Factor Loadings}

The NSS model can be written as:
\begin{equation}
    y(\tau) = \beta_0 L_0(\tau) + \beta_1 L_1(\tau) + \beta_2 L_2(\tau) + \beta_3 L_3(\tau)
\end{equation}

where the factor loadings are:
\begin{align}
    L_0(\tau) &= 1 \quad \text{(level)} \\
    L_1(\tau) &= \frac{1-e^{-\tau/\lambda_1}}{\tau/\lambda_1} \quad \text{(slope)} \\
    L_2(\tau) &= \frac{1-e^{-\tau/\lambda_1}}{\tau/\lambda_1} - e^{-\tau/\lambda_1} \quad \text{(curvature 1)} \\
    L_3(\tau) &= \frac{1-e^{-\tau/\lambda_2}}{\tau/\lambda_2} - e^{-\tau/\lambda_2} \quad \text{(curvature 2)}
\end{align}

\subsection{Forward Rate Derivation}

The instantaneous forward rate is:
\begin{equation}
    f(\tau) = y(\tau) + \tau \frac{dy}{d\tau}
\end{equation}

Taking the derivative:
\begin{equation}
    f(\tau) = \beta_0 + \beta_1 e^{-\tau/\lambda_1} + \beta_2 \frac{\tau}{\lambda_1} e^{-\tau/\lambda_1} + \beta_3 \frac{\tau}{\lambda_2} e^{-\tau/\lambda_2}
\end{equation}

\chapter{Glossary}

\begin{description}[style=nextline]
    \item[ACT/360] Day count convention using actual days divided by 360.
    \item[ACT/365] Day count convention using actual days divided by 365.
    \item[ACT/ACT] Day count convention using actual days divided by actual days in the year.
    \item[Alpha ($\alpha$)] SABR instantaneous volatility parameter; controls overall vol level.
    \item[Anchor Date] The valuation date from which all time calculations are measured.
    \item[Backbone] The relationship between ATM volatility and forward level in SABR.
    \item[Bachelier Model] Option pricing model assuming normal (arithmetic) dynamics; used for normal vol quoting.
    \item[Beta ($\beta$)] SABR CEV exponent; $\beta=0$ is normal, $\beta=1$ is lognormal.
    \item[Black'76 Model] Option pricing model for forwards/futures assuming lognormal dynamics.
    \item[Bootstrap] Sequential curve construction method solving for discount factors one at a time.
    \item[Bucket] A (expiry, tenor) combination in SABR surface calibration.
    \item[Caplet] A call option on a forward interest rate for a single period.
    \item[Convexity] Second derivative of price with respect to yield.
    \item[Coverage Ratio] Fraction of portfolio successfully priced (useful for VaR diagnostics).
    \item[CurveState] Container for discount and projection curves in MarketState.
    \item[Delta (SABR)] Model-consistent delta including smile dynamics: $\Delta_{\text{SABR}} = \Delta_{\text{base}} + \mathcal{V} \cdot \partial\sigma/\partial F$.
    \item[Discount Factor] Present value of \$1 to be received at a future date.
    \item[DV01] Dollar Value of 01 basis point - price change for 1bp parallel shift.
    \item[Expected Shortfall (ES)] Average loss given that VaR is exceeded; also called CVaR.
    \item[Forward Rate] Interest rate agreed today for a future period.
    \item[Hagan Approximation] Analytical formula for SABR implied volatility.
    \item[Key-Rate Duration] Sensitivity to a shift at a specific curve tenor.
    \item[LVaR] Liquidity-adjusted VaR including bid-ask spread costs.
    \item[MarketState] Unified container for curves, SABR surface, and valuation date.
    \item[Modified Duration] Percentage price sensitivity to yield changes.
    \item[Nelson-Siegel-Svensson (NSS)] Parametric yield curve model with 6 parameters.
    \item[Nu ($\nu$)] SABR volatility-of-volatility parameter.
    \item[OIS] Overnight Index Swap - swap exchanging fixed rate for overnight rate.
    \item[P\&L Attribution] Decomposition of profit/loss into explanatory components.
    \item[Par Rate] Swap rate that makes the swap have zero initial value.
    \item[Portfolio Builder] Validated trade construction function with error diagnostics.
    \item[Rho ($\rho$)] SABR correlation parameter between forward and volatility.
    \item[Roll-down] P\&L from the position aging on an unchanged curve.
    \item[SABR] Stochastic Alpha Beta Rho model for volatility smile dynamics.
    \item[SABR Surface] Bucketed collection of SABR parameters by (expiry, tenor).
    \item[Shifted SABR] SABR variant allowing negative forwards via a shift parameter.
    \item[Sideways] Component of smile dynamics from moneyness change at fixed ATM vol.
    \item[Sigma\_ATM ($\sigma_{\text{ATM}}$)] At-the-money implied volatility (calibration input).
    \item[Smile] The variation of implied volatility across strikes.
    \item[Swaption] An option to enter into an interest rate swap.
    \item[Vanna] Sensitivity of option value to correlation ($\partial V/\partial\rho$) or cross-gamma.
    \item[VaR] Value at Risk - loss exceeded with specified probability.
    \item[Vega] Sensitivity of option value to volatility.
    \item[Volga] Sensitivity of option value to vol-of-vol ($\partial V/\partial\nu$) or vol convexity.
    \item[Wildcard Bucket] The ("ALL", "ALL") bucket providing universal fallback for missing SABR calibrations.
    \item[Zero Rate] Yield on a zero-coupon bond of given maturity.
\end{description}

\chapter{References}

\begin{enumerate}
    \item Nelson, C.R. and Siegel, A.F. (1987). ``Parsimonious Modeling of Yield Curves.'' \textit{Journal of Business}, 60(4), 473-489.
    
    \item Svensson, L.E.O. (1994). ``Estimating and Interpreting Forward Interest Rates: Sweden 1992-1994.'' \textit{IMF Working Paper} 94/114.
    
    \item Fabozzi, F.J. (2007). \textit{Fixed Income Analysis}. 2nd ed. Wiley.
    
    \item Hull, J.C. (2018). \textit{Options, Futures, and Other Derivatives}. 10th ed. Pearson.
    
    \item Jorion, P. (2007). \textit{Value at Risk: The New Benchmark for Managing Financial Risk}. 3rd ed. McGraw-Hill.
    
    \item Tuckman, B. and Serrat, A. (2011). \textit{Fixed Income Securities: Tools for Today's Markets}. 3rd ed. Wiley.
    
    \item Hagan, P.S., Kumar, D., Lesniewski, A.S., and Woodward, D.E. (2002). ``Managing Smile Risk.'' \textit{Wilmott Magazine}, September, 84-108.
    
    \item Hagan, P.S. and Woodward, D.E. (1999). ``Equivalent Black Volatilities.'' \textit{Applied Mathematical Finance}, 6(3), 147-157.
    
    \item Rebonato, R. (2004). \textit{Volatility and Correlation: The Perfect Hedger and the Fox}. 2nd ed. Wiley.
    
    \item Antonov, A. and Spector, M. (2012). ``Advanced Analytics for the SABR Model.'' \textit{SSRN Working Paper}.
    
    \item Bartlett, B. (2006). ``Hedging Under SABR Model.'' \textit{Wilmott Magazine}, July, 2-4.
    
    \item West, G. (2005). ``Calibration of the SABR Model in Illiquid Markets.'' \textit{Applied Mathematical Finance}, 12(4), 371-385.
    
    \item Streamlit Inc. (2024). \textit{Streamlit Documentation}. https://docs.streamlit.io
    
    \item Plotly Technologies Inc. (2024). \textit{Plotly Python Graphing Library}. https://plotly.com/python/
    
    \item \textit{Rates Risk Library Repository}. https://github.com/7josh7/rates\_risk\_lib
\end{enumerate}

\end{document}
